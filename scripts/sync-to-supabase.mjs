#!/usr/bin/env node
/**
 * Sync jobs from fetcher outputs to Supabase
 * 
 * Reads JSON files generated by fetchers and uploads to Supabase jobs table.
 * Uses upsert to prevent duplicates (inserts new, updates existing).
 * 
 * Usage:
 *   node scripts/sync-to-supabase.mjs
 */

import { readFileSync, existsSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { createClient } from '@supabase/supabase-js';
import 'dotenv/config';

// ============================================================================
// CONFIGURATION
// ============================================================================

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  console.error('‚ùå Missing Supabase credentials!');
  console.error('   Set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY in .env');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Input files
const INPUT_FILES = [
  'lever-jobs-output.json',
  'greenhouse-jobs-output.json',
  'ashby-jobs-output.json', // ‚úÖ FIXED!
];

// ============================================================================
// NORMALIZATION FUNCTIONS
// ============================================================================

/**
 * Map our category names to database-compatible values
 */
function mapCategory(category) {
  const categoryMap = {
    'Game Dev': 'game-dev',
    '3D': '3d-and-animation',
    '2D Art': '2d-art',
    'Animation': 'animation',
    'Design': 'design',
    'VFX': 'vfx',
  };

  return categoryMap[category] || 'design';
}

/**
 * Map contract types to database enum values
 * 
 * Note: CLT is Brazil-specific. For international jobs, we use more generic types.
 * 
 * @param {string} contractType - Contract type from job data
 * @param {string} locationScope - Location scope (remote-worldwide, remote-brazil, etc.)
 * @returns {string} Mapped contract type
 */
function mapContractType(contractType, locationScope = 'remote-worldwide') {
  if (!contractType) {
    // Default based on location
    if (locationScope === 'remote-brazil' || locationScope === 'hybrid') {
      return 'PJ'; // Default for Brazil
    }
    return null; // Unknown for international
  }

  const typeMap = {
    'Full-time': locationScope === 'remote-brazil' || locationScope === 'hybrid' ? 'CLT' : null,
    'full-time': locationScope === 'remote-brazil' || locationScope === 'hybrid' ? 'CLT' : null,
    'Part-time': 'PJ',
    'part-time': 'PJ',
    'Contract': 'B2B',
    'contract': 'B2B',
    'Freelance': 'Freelance',
    'freelance': 'Freelance',
    'Internship': 'Est√°gio',
    'internship': 'Est√°gio',
    'Intern': 'Est√°gio',
  };

  return typeMap[contractType] || (locationScope === 'remote-brazil' || locationScope === 'hybrid' ? 'PJ' : null);
}

/**
 * Map location scope to database enum values
 */
function mapLocationScope(scope) {
  const scopeMap = {
    'remote-worldwide': 'Remoto - Internacional',
    'remote-brazil': 'Remoto - Brasil',
    'remote-latam': 'Remoto - Am√©rica Latina',
    'hybrid': 'H√≠brido',
    'onsite': 'Presencial',
  };

  return scopeMap[scope] || 'Remoto - Internacional';
}

/**
 * Detect salary currency based on location and job data
 * 
 * @param {string} providedCurrency - Currency from job data
 * @param {string} locationScope - Location scope
 * @param {string} locationText - Location detail text
 * @returns {string} Detected currency
 */
function detectSalaryCurrency(providedCurrency, locationScope, locationText = '') {
  // If currency is explicitly provided, use it
  if (providedCurrency) {
    return providedCurrency.toUpperCase();
  }

  // Detect based on location
  const locationLower = (locationText || '').toLowerCase();
  
  // Brazil-specific locations
  if (locationScope === 'remote-brazil' || locationScope === 'hybrid') {
    if (locationLower.includes('brasil') || locationLower.includes('brazil') || locationLower.includes('s√£o paulo')) {
      return 'BRL';
    }
  }

  // US-specific locations
  if (locationLower.includes('us') || locationLower.includes('united states') || locationLower.includes('americas')) {
    return 'USD';
  }

  // Europe-specific locations
  if (locationLower.includes('europe') || locationLower.includes('eu') || locationLower.includes('uk')) {
    return 'EUR';
  }

  // LATAM
  if (locationScope === 'remote-latam') {
    return 'USD'; // Most LATAM companies use USD
  }

  // Default: BRL for Brazil-focused, USD for international
  if (locationScope === 'remote-brazil' || locationScope === 'hybrid') {
    return 'BRL';
  }

  return 'USD'; // Default for international
}

/**
 * Get or create a category and return its ID
 */
async function ensureCategory(categorySlug) {
  // Map slug back to display name
  const nameMap = {
    'game-dev': 'Game Dev',
    '3d-and-animation': '3D',
    '2d-art': '2D Art',
    'animation': 'Animation',
    'design': 'Design',
    'vfx': 'VFX',
  };

  const categoryName = nameMap[categorySlug] || 'Design';

  // Try to get existing category
  const { data: existing, error: selectError } = await supabase
    .from('categories')
    .select('id')
    .eq('name', categoryName)
    .single();

  if (existing) {
    return existing.id;
  }

  // Create if doesn't exist
  const { data: created, error: insertError } = await supabase
    .from('categories')
    .insert({ name: categoryName })
    .select('id')
    .single();

  if (insertError) {
    console.error(`Error creating category ${categoryName}:`, insertError.message);
    return null;
  }

  return created.id;
}

/**
 * Get or create a tag and return its ID
 */
async function ensureTag(tagName) {
  if (!tagName || tagName.trim() === '') return null;
  
  const normalizedTag = tagName.trim();

  // Try to get existing tag
  const { data: existing } = await supabase
    .from('tags')
    .select('id')
    .eq('name', normalizedTag)
    .single();

  if (existing) {
    return existing.id;
  }

  // Create if doesn't exist
  const { data: created, error: insertError } = await supabase
    .from('tags')
    .insert({ name: normalizedTag })
    .select('id')
    .single();

  if (insertError) {
    // Tag might have been created by another process
    const { data: retry } = await supabase
      .from('tags')
      .select('id')
      .eq('name', normalizedTag)
      .single();
    
    return retry?.id || null;
  }

  return created?.id || null;
}

/**
 * Sync tags for a job
 */
async function syncJobTags(jobId, tags) {
  if (!tags || tags.length === 0) return;

  // First, delete existing tags for this job
  await supabase
    .from('job_tags')
    .delete()
    .eq('job_id', jobId);

  // Then add new tags
  for (const tagName of tags) {
    const tagId = await ensureTag(tagName);
    
    if (tagId) {
      const { error } = await supabase
        .from('job_tags')
        .upsert(
          { job_id: jobId, tag_id: tagId },
          { onConflict: 'job_id,tag_id', ignoreDuplicates: true }
        );

      if (error && !error.message.includes('duplicate')) {
        console.warn(`    ‚ö†Ô∏è Error adding tag "${tagName}": ${error.message}`);
      }
    }
  }
}

/**
 * Get or create a company and return its ID
 */
async function ensureCompany(companyName, logoUrl) {
  // Try to get existing company
  const { data: existing, error: selectError } = await supabase
    .from('companies')
    .select('id')
    .eq('name', companyName)
    .single();

  if (existing) {
    return existing.id;
  }

  // Create if doesn't exist
  const { data: created, error: insertError } = await supabase
    .from('companies')
    .insert({
      name: companyName,
      logo_url: logoUrl || 'https://remotejobsbr.com/images/company-placeholder.svg',
    })
    .select('id')
    .single();

  if (insertError) {
    console.error(`Error creating company ${companyName}:`, insertError.message);
    return null;
  }

  return created.id;
}

/**
 * Normalize job data from fetcher format to Supabase schema
 * Returns null if required IDs cannot be obtained
 */
async function normalizeJobForSupabase(job) {
  // Get or create category
  const categorySlug = mapCategory(job.category);
  const categoryId = await ensureCategory(categorySlug);

  if (!categoryId) {
    console.error(`Failed to get category ID for ${job.category}`);
    return null;
  }

  // Get or create company
  const companyId = await ensureCompany(job.companyName, job.companyLogo);

  if (!companyId) {
    console.error(`Failed to get company ID for ${job.companyName}`);
    return null;
  }

  // Detect source from job ID prefix
  let source = 'manual';
  if (job.id.startsWith('WIL-')) source = 'greenhouse';
  else if (job.id.startsWith('FAN-')) source = 'lever';
  else if (job.id.startsWith('DEL-') || job.id.startsWith('ASH-')) source = 'ashby';

  return {
    id: job.id,
    company_id: companyId,
    category_id: categoryId,
    job_title: job.jobTitle,
    description: job.description,
    short_description: job.shortDescription || job.description.substring(0, 200) + '...',
    apply_link: job.applyLink,
    date_posted: job.postedDate ? job.postedDate.split('T')[0] : new Date().toISOString().split('T')[0],
    location_scope: job.location.scope, // Use original scope (not mapped)
    location_detail: job.location.text || '',
    contract_type: mapContractType(job.contractType, job.location.scope),
    salary_min: job.salary?.min || null,
    salary_max: job.salary?.max || null,
    salary_currency: detectSalaryCurrency(job.salary?.currency, job.location.scope, job.location.text),
    company_logo_url: job.companyLogo || 'https://remotejobsbr.com/images/company-placeholder.svg',
    source: source,
    status: 'ativa',
  };
}

// ============================================================================
// SYNC FUNCTIONS
// ============================================================================

/**
 * Load jobs from a JSON file
 */
function loadJobsFromFile(filename) {
  const filePath = join(__dirname, filename);

  if (!existsSync(filePath)) {
    console.warn(`‚ö†Ô∏è  File not found: ${filename}`);
    return [];
  }

  try {
    const content = readFileSync(filePath, 'utf-8');
    const jobs = JSON.parse(content);

    if (!Array.isArray(jobs)) {
      console.error(`‚ùå Invalid JSON format in ${filename} (expected array)`);
      return [];
    }

    console.log(`üìÇ Loaded ${jobs.length} jobs from ${filename}`);
    return jobs;
    
  } catch (error) {
    console.error(`‚ùå Error reading ${filename}:`, error.message);
    return [];
  }
}

/**
 * Sync a batch of jobs to Supabase
 */
async function syncJobsToSupabase(jobs) {
  if (jobs.length === 0) {
    console.log('   ‚ÑπÔ∏è  No jobs to sync');
    return { success: 0, errors: 0 };
  }

  let successCount = 0;
  let errorCount = 0;

  console.log(`\nüîÑ Syncing ${jobs.length} jobs to Supabase...`);

  for (let i = 0; i < jobs.length; i++) {
    const job = jobs[i];
    
    try {
      const normalizedJob = await normalizeJobForSupabase(job);

      if (!normalizedJob) {
        console.error(`  ‚ùå [${i + 1}/${jobs.length}] Failed to normalize ${job.id}`);
        errorCount++;
        continue;
      }

      const { error } = await supabase
        .from('jobs')
        .upsert(normalizedJob, {
          onConflict: 'id',
          ignoreDuplicates: false, // Update if already exists
        });

      if (error) {
        console.error(`  ‚ùå [${i + 1}/${jobs.length}] Error syncing ${job.id}: ${error.message}`);
        errorCount++;
        continue;
      }

      // Sync tags for this job
      if (job.tags && job.tags.length > 0) {
        await syncJobTags(job.id, job.tags);
      }

      console.log(`  ‚úÖ [${i + 1}/${jobs.length}] Synced: ${job.id} - ${job.jobTitle} (${job.tags?.length || 0} tags)`);
      successCount++;

      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 150));

    } catch (error) {
      console.error(`  ‚ùå [${i + 1}/${jobs.length}] Unexpected error: ${error.message}`);
      errorCount++;
    }
  }

  return { success: successCount, errors: errorCount };
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function main() {
  console.log('üöÄ Starting Supabase sync...');
  console.log('‚ïê'.repeat(60));

  let totalJobs = 0;
  let totalSuccess = 0;
  let totalErrors = 0;

  // Load and sync jobs from each input file
  for (const filename of INPUT_FILES) {
    console.log(`\nüìã Processing: ${filename}`);
    console.log('‚îÄ'.repeat(60));

    const jobs = loadJobsFromFile(filename);
    totalJobs += jobs.length;

    if (jobs.length > 0) {
      const { success, errors } = await syncJobsToSupabase(jobs);
      totalSuccess += success;
      totalErrors += errors;
    }
  }

  // Final summary
  console.log('\n' + '‚ïê'.repeat(60));
  console.log('üéâ Sync Complete!');
  console.log('‚ïê'.repeat(60));
  console.log(`üìä Summary:`);
  console.log(`   Total jobs processed: ${totalJobs}`);
  console.log(`   ‚úÖ Successfully synced: ${totalSuccess}`);
  console.log(`   ‚ùå Errors: ${totalErrors}`);
  console.log('‚ïê'.repeat(60));

  if (totalErrors > 0) {
    console.warn(`\n‚ö†Ô∏è  There were ${totalErrors} errors during sync.`);
    console.warn('   Review the logs above and check your Supabase schema.');
    process.exit(1);
  }

  console.log('\n‚ú® All jobs synced successfully!');
  console.log('   Visit your Supabase Table Editor to verify: https://app.supabase.com');
}

main().catch(error => {
  console.error('\nüí• Fatal error:', error.message);
  console.error(error.stack);
  process.exit(1);
});

