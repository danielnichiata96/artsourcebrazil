import { describe, it, expect, beforeAll } from 'vitest';
import { readFileSync } from 'node:fs';
import { resolve } from 'node:path';

/**
 * Integration tests for fetch-greenhouse-jobs.mjs
 * 
 * Tests the Greenhouse fetcher script to ensure:
 * - Job data is fetched correctly
 * - Categories are assigned properly
 * - Invalid jobs are rejected
 * - Output structure is valid
 */

describe('fetch-greenhouse-jobs.mjs', () => {
  let jobs: any[];
  
  beforeAll(() => {
    // Read the output file generated by the fetcher
    // NOTE: Fetchers output JSON arrays directly, not objects with { jobs: [] }
    try {
      const outputPath = resolve(process.cwd(), 'scripts/greenhouse-jobs-output.json');
      const content = readFileSync(outputPath, 'utf-8');
      jobs = JSON.parse(content);
      
      // Ensure it's an array
      if (!Array.isArray(jobs)) {
        jobs = [];
      }
    } catch (error) {
      console.warn('⚠️  Greenhouse output not found. Run: node scripts/fetch-greenhouse-jobs.mjs');
      jobs = [];
    }
  });

  describe('Output Structure', () => {
    it('is an array of jobs', () => {
      expect(Array.isArray(jobs)).toBe(true);
    });

    it('contains job objects', () => {
      if (jobs.length > 0) {
        expect(typeof jobs[0]).toBe('object');
        expect(jobs[0]).not.toBeNull();
      }
    });
  });

  describe('Job Data Validation', () => {
    it('all jobs have required fields', () => {
      
      if (jobs.length === 0) {
        console.warn('⚠️  No jobs to test. Run fetcher first.');
        return;
      }

      jobs.forEach((job: any, index: number) => {
        expect(job, `Job ${index} missing id`).toHaveProperty('id');
        expect(job, `Job ${index} missing jobTitle`).toHaveProperty('jobTitle');
        expect(job, `Job ${index} missing companyName`).toHaveProperty('companyName');
        expect(job, `Job ${index} missing category`).toHaveProperty('category');
        expect(job, `Job ${index} missing applyLink`).toHaveProperty('applyLink');
        expect(job, `Job ${index} missing postedDate`).toHaveProperty('postedDate');
      });
    });

    it('all jobs have valid categories', () => {
      const validCategories = ['Engineering & Code', 'Art & Animation', 'Design & Product', 'Production'];

      jobs.forEach((job: any) => {
        expect(validCategories).toContain(job.category);
      });
    });

    it('all job IDs are unique', () => {
      const ids = jobs.map((j: any) => j.id);
      const uniqueIds = new Set(ids);
      
      expect(uniqueIds.size).toBe(ids.length);
    });

    it('all jobs have valid location scope', () => {
      const validScopes = ['remote-brazil', 'remote-latam', 'remote-worldwide', 'hybrid', 'onsite'];

      jobs.forEach((job: any) => {
        expect(job).toHaveProperty('location');
        expect(job.location).toHaveProperty('scope');
        expect(validScopes).toContain(job.location.scope);
      });
    });

    it('all jobs have tags array', () => {

      jobs.forEach((job: any) => {
        expect(job).toHaveProperty('tags');
        expect(Array.isArray(job.tags)).toBe(true);
      });
    });
  });

  describe('Categorization Quality', () => {
    it('engineers are not categorized as Design', () => {
      const engineerJobs = jobs.filter((j: any) => 
        j.jobTitle.toLowerCase().includes('engineer') && 
        !j.jobTitle.toLowerCase().includes('design engineer') &&
        !j.jobTitle.toLowerCase().includes('manager') // Manager roles can be Production
      );

      engineerJobs.forEach((job: any) => {
        expect(job.category).not.toBe('Design & Product');
        // Engineering jobs should be Engineering & Code, but may be Production if management
        expect(['Engineering & Code', 'Production']).toContain(job.category);
      });
    });

    it('artists are categorized as Art & Animation', () => {
      const artistJobs = jobs.filter((j: any) => j.jobTitle.toLowerCase().includes('artist'));

      artistJobs.forEach((job: any) => {
        expect(job.category).toBe('Art & Animation');
      });
    });

    it('designers are categorized as Design & Product', () => {
      const designerJobs = jobs.filter((j: any) => 
        j.jobTitle.toLowerCase().includes('designer') &&
        !j.jobTitle.toLowerCase().includes('design engineer')
      );

      designerJobs.forEach((job: any) => {
        expect(job.category).toBe('Design & Product');
      });
    });
  });

  describe('Rejection Logic', () => {
    it('does not include HR jobs', () => {
      const hrJobs = jobs.filter((j: any) => 
        j.jobTitle.toLowerCase().includes('hr') ||
        j.jobTitle.toLowerCase().includes('human resources')
      );

      expect(hrJobs.length).toBe(0);
    });

    it('does not include finance jobs', () => {
      const financeJobs = jobs.filter((j: any) => 
        j.jobTitle.toLowerCase().includes('finance') ||
        j.jobTitle.toLowerCase().includes('accounting')
      );

      expect(financeJobs.length).toBe(0);
    });

    it('does not include sales jobs', () => {
      const salesJobs = jobs.filter((j: any) => 
        j.jobTitle.toLowerCase().includes('sales representative')
      );

      expect(salesJobs.length).toBe(0);
    });
  });

  describe('Data Quality', () => {
    it('descriptions are not empty', () => {

      jobs.forEach((job: any) => {
        expect(job.description).toBeTruthy();
        expect(job.description.length).toBeGreaterThan(50);
      });
    });

    it('apply links are valid URLs', () => {

      jobs.forEach((job: any) => {
        expect(job.applyLink).toMatch(/^https?:\/\//);
      });
    });

    it('posted dates are valid ISO strings', () => {

      jobs.forEach((job: any) => {
        const date = new Date(job.postedDate);
        expect(date.toString()).not.toBe('Invalid Date');
      });
    });
  });

  describe('ArchViz Support', () => {
    it('categorizes ArchViz jobs as Art & Animation', () => {
      const archvizJobs = jobs.filter((j: any) => 
        j.jobTitle.toLowerCase().includes('archviz') ||
        j.jobTitle.toLowerCase().includes('architectural visualization')
      );

      archvizJobs.forEach((job: any) => {
        expect(job.category).toBe('Art & Animation');
      });
    });
  });
});

